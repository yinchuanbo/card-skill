
<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>如果一个NPM包部分功能不满足需求，如何修改器部分功能</title>
    <link rel="stylesheet" href="/css/styles.css">
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=JetBrains+Mono:wght@300;400;500;600;700&family=Ma+Shan+Zheng&family=ZCOOL+XiaoWei&family=ZCOOL+QingKe+HuangYou&family=Noto+Serif+SC:wght@300;400;500;600;700&display=swap" rel="stylesheet">
    <!-- Prism.js CSS -->
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/prismjs@1.29.0/themes/prism-tomorrow.min.css">
</head>
<body class="card-detail">
    <div class="container">
        <div class="card-content">
            <header>
                <h1>如果一个NPM包部分功能不满足需求，如何修改器部分功能</h1>
                <div class="meta">
                    <time datetime="Sun Mar 09 2025 18:40:04 GMT+0800 (中国标准时间)">2025/3/9</time>
                    <div class="tags">
                        <span class="tag">前端工程化</span>
                    </div>
                </div>
            </header>
            <div class="content">
                <p>对第三方包进行修改以适应特定需求是一个常见的场景。尽管直接修改 node_modules 中的代码是可能的，但这种做法并不推荐，因为这些改动在下次运行 <code>npm install</code> 或更新包时会丢失。</p>
<p>接下来的内容中，我们将来讲解一下处理这种情况的几种推荐方法。</p>
<h2 id="使用-fork">使用 Fork</h2>
<p>最常见的方法就是 Fork 源代码，通过在 GitHub 上或其他托管平台上 Fork 第三方包的源代码库。对其源代码进行修改，修改完成后将修改后的包发布到 npm 上。如果你不希望它是公开的，那么你可以搭建一个 npm 的私有包。直接将项目中的包切换我们自己发布的包。</p>
<h2 id="提交-pr">提交 PR</h2>
<p>如果你认为你的修改对其他用户也有帮助，可以向原始包的维护者提交 <code>Pull Request（PR）</code>。如果 PR 被接受并合并，那么你就可以直接使用未来版本的官方包，而不需要维护一个 Fork。</p>
<h2 id="本地修改与补丁">本地修改与补丁</h2>
<p>本地修改与补丁方法允许我们对 <code>node_modules</code> 中的包进行必要的修改，同时通过补丁文件的形式保存这些修改。这种方式既可以避免直接修改 <code>node_modules</code> 目录下的代码，也确保了项目的其他成员或在其他环境中部署时能够应用同样的修改。具体步骤如下：</p>
<ol>
<li>在本地对包进行修改：直接在项目的 node_modules 目录下找到并修改对应的第三方包文件。虽然这种修改是临时的，但是接下来的步骤会帮助我们保存这些改动。</li>
<li>创建补丁文件：一旦完成了必要的修改，你可以使用 git diff 或其他差异比较工具来生成一个补丁文件。这个文件记录了修改的内容。如果你的项目使用 Git 进行版本控制，可以先提交所有其他更改，以便 git diff 只显示对第三方包的修改。</li>
</ol>
<pre><code class="language-sh"><pre data-language="sh"><code class="language-sh"><span class="token function">git</span> <span class="token function">diff</span> <span class="token operator">></span> patches/third-party-package.patch</code></pre>
</code></pre>
<ol>
<li>应用补丁：为了自动化地在每次安装依赖时应用这个补丁，你可以使用如 <code>patch-package</code> 这样的工具。<code>patch-package</code> 允许在 node_modules 中的包上应用补丁，并且这些补丁可以和你的项目代码一起被版本控制。</li>
</ol>
<p>首先，安装 patch-package：</p>
<pre><code class="language-sh"><pre data-language="sh"><code class="language-sh"><span class="token function">npm</span> <span class="token function">install</span> patch-package postinstall-postinstall --save-dev</code></pre>
</code></pre>
<p>然后，将应用补丁的步骤添加到 package.json 中的 scripts 字段：</p>
<pre><code class="language-json"><pre data-language="json"><code class="language-json"><span class="token punctuation">{</span>
  <span class="token property">"scripts"</span><span class="token operator">:</span> <span class="token punctuation">{</span>
    <span class="token property">"postinstall"</span><span class="token operator">:</span> <span class="token string">"patch-package"</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span></code></pre>
</code></pre>
<p>这样，每次运行 npm install 时，postinstall 脚本都会执行，自动应用保存在 patches/目录下的所有补丁。</p>
<p>假设我们要要修改 axios 包，那么我们可以直接在项目的 <code>node_modules/axios</code> 目录下对 axios 进行必要的修改。这些修改可以是任何东西，从简单的配置更改到函数逻辑的更新。</p>
<h2 id="生成补丁">生成补丁</h2>
<p>使用 patch-package 生成一个补丁文件。这个命令会比较你对 node_modules 中 axios 的修改，并将这些修改保存为一个补丁文件。</p>
<pre><code class="language-sh"><pre data-language="sh"><code class="language-sh">npx patch-package axios</code></pre>
</code></pre>
<p>执行这个命令后，patch-package 会在项目的根目录下创建一个 patches 目录（如果还没有的话），并在里面生成一个名为 axios+版本号.patch 的文件，其中版本号是你项目中使用的 axios 的版本。</p>
<p>为了验证补丁是否会被正确应用，你可以尝试删除 node_modules 目录并重新安装依赖：</p>
<pre><code class="language-sh"><pre data-language="sh"><code class="language-sh"><span class="token function">rm</span> <span class="token parameter variable">-rf</span> node_modules
<span class="token function">npm</span> <span class="token function">install</span></code></pre>
</code></pre>
<p>在 npm install 执行完成后，patch-package 会自动运行并应用你之前创建的补丁，将你对 axios 的修改重新应用到新安装的 axios 包上。</p>
<p>这样，你就完成了对 axios 的修改，以及配置项目自动应用这些修改的整个流程。</p>
<p>最终的结果如下图所示：</p>
<p><img src="images/21.webp" alt=""></p>
<h2 id="包装第三方包">包装第三方包</h2>
<p>包装第三方包方法涉及创建一个新的模块（或包），专门用来封装第三方包。通过这种方式，你可以在不直接修改原始包的情况下，添加新的功能、修改现有方法或者调整方法的行为。</p>
<p>创建一个新的文件（如 third-party-wrapper.js），在这个文件中导入第三方包，并实现需要修改或扩展的功能。</p>
<pre><code class="language-js"><pre data-language="js"><code class="language-js"><span class="token comment">// third-party-wrapper.js</span>
<span class="token keyword">import</span> <span class="token punctuation">{</span> foo <span class="token punctuation">}</span> <span class="token keyword">from</span> <span class="token string">"axios"</span><span class="token punctuation">;</span>

<span class="token comment">// 修改或扩展someFunction的行为</span>
<span class="token keyword">export</span> <span class="token keyword">function</span> <span class="token function">enhancedSomeFunction</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token comment">// 在调用原始函数之前执行一些操作</span>
  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">"你好"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

  <span class="token comment">// 调用原始函数</span>
  <span class="token keyword">let</span> result <span class="token operator">=</span> <span class="token function">foo</span><span class="token punctuation">.</span><span class="token function">apply</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">,</span> arguments<span class="token punctuation">)</span><span class="token punctuation">;</span>

  <span class="token comment">// 在调用原始函数之后执行一些操作</span>
  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">"小黑子"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

  <span class="token comment">// 返回结果</span>
  <span class="token keyword">return</span> result<span class="token punctuation">;</span>
<span class="token punctuation">}</span></code></pre>
</code></pre>
<p>在项目中的其他部分，你可以直接引入并使用这个封装模块，而不是直接使用第三方包。这样，你就可以利用修改后的功能，同时避免了对第三方包的直接修改。</p>
<pre><code class="language-js"><pre data-language="js"><code class="language-js"><span class="token keyword">import</span> <span class="token punctuation">{</span> enhancedSomeFunction <span class="token punctuation">}</span> <span class="token keyword">from</span> <span class="token string">"./third-party-wrapper"</span><span class="token punctuation">;</span>

<span class="token function">enhancedSomeFunction</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre>
</code></pre>
<p>这种方法的好处是，它提供了一个清晰的隔离层，使得第三方包的任何更新不会直接影响到你对功能的定制。同时，这也使得维护和升级第三方包变得更加容易，因为你只需要在封装层中做出相应的调整。</p>
<h2 id="总结">总结</h2>
<p>通过上面这四种方法，我们应该对这个场景有比较熟悉的理解了，选择哪种方法取决于你的具体需求、对第三方包的修改程度以及是否希望将这些修改贡献给社区。通常，提交 PR 和使用 Fork 是首选方法，因为它们可以避免维护自定义修改所带来的长期负担。</p>

            </div>
        </div>
        
        <div class="return-link">
            <a href="/">&larr; 返回卡片列表</a>
        </div>
    </div>

    <!-- 简化后的模态框结构 -->
    <div class="modal-overlay" id="modalOverlay">
        <button class="modal-close" id="modalClose">&times;</button>
        <div id="modalContent">
            <!-- 模态框内容将在这里加载 -->
        </div>
    </div>
    
    <script src="/js/main.js"></script>
    <script src="/js/ink-effects.js"></script>
    <!-- Prism.js JavaScript -->
    <script src="https://cdn.jsdelivr.net/npm/prismjs@1.29.0/prism.min.js"></script>
    <!-- 添加额外的语言支持 -->
    <script src="https://cdn.jsdelivr.net/npm/prismjs@1.29.0/components/prism-javascript.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/prismjs@1.29.0/components/prism-css.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/prismjs@1.29.0/components/prism-python.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/prismjs@1.29.0/components/prism-java.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/prismjs@1.29.0/components/prism-bash.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/prismjs@1.29.0/components/prism-yaml.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/prismjs@1.29.0/components/prism-json.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/prismjs@1.29.0/components/prism-markdown.min.js"></script>
    <!-- 重新初始化Prism.js -->
    <script>
        document.addEventListener('DOMContentLoaded', function() {
            // 手动触发Prism高亮，确保动态加载的内容也能高亮
            Prism.highlightAll();
        });
    </script>
</body>
</html>